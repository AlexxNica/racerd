Just some notes I wrote while planning the project

## YCM Protocol

### /event_notification

The first http request in the example client is an event notification.

```http
POST /event_notification HTTP/1.1
```

The request payload has the following format.

```json
{
    "column_num": 1,
    "event_name": "FileReadyToParse",
    "file_data": {
        "<absolute path of file>": {
            "contents": "<file contents with escaped newlines>",
            "filetypes": [
                "<the filetype; in our case, rust.>"
            ]
        }
    },
    "filepath": "<absolute path of file>",
    "line_num": 1
}
```

There are 4 event notifications generated by the example client. They all
contain the same *event_name*, `FileReadyToParse`. 3 of the event notification
responses were simply empty JSON objects. The other event notification response
was a list of issues generated during parsing. The issue objects have the
following format.

```json
{
    "fixit_available": true,
    "kind": "ERROR",
    "location": {
        "column_num": 8,
        "filepath": "/Users/jwilm/code/ycmd/examples/samples/some_cpp.cpp",
        "line_num": 17
    },
    "location_extent": {
        "end": {
            "column_num": 0,
            "filepath": "",
            "line_num": 0
        },
        "start": {
            "column_num": 0,
            "filepath": "",
            "line_num": 0
        }
    },
    "ranges": [],
    "text": "expected ';' at end of declaration list"
}
```

After grepping around for `kind` and `ERROR` in the ycmd codebase, the only
results that jumped out to me were in some integration tests, and they only
checked if `kind` was equal to `ERROR`. I know that YCM can display warning as
well. Maybe that's automatic when `kind` is not provided?

### /completions

This is the endpoint hit when performing autocomplete. Have 4 queries from the
example client.

```http
POST /completions HTTP/1.1
```

A typical request:

```json
{
    "column_num": 6,
    "file_data": {
        "/Users/jwilm/code/ycmd/examples/samples/some_javascript.js": {
            "contents": "<code>",
            "filetypes": [
                "javascript"
            ]
        }
    },
    "filepath": "/Users/jwilm/code/ycmd/examples/samples/some_javascript.js",
    "line_num": 21
}
```

The response is almost simply a list of completions. It has the following form.

```json
{
    "completion_start_column": 15,
    "completions": [
        {
            "detailed_info": "ConsoleColor BackgroundColor { get; set; }\n",
            "extra_data": {
                "required_namespace_import": null
            },
            "extra_menu_info": "ConsoleColor BackgroundColor { get; set; }",
            "insertion_text": "BackgroundColor"
        }
    ],
    "errors": [ ]
}
```

However, the completions objects can vary. The above example was for a C#
completion.

JavaScript:

```json
{
    "extra_menu_info": "[ID]",
    "insertion_text": "foobar"
}
```

Python:

```json
{
    "extra_data": {
        "location": {
            "column_num": 10,
            "filepath": "/Users/jwilm/code/ycmd/examples/samples/some_python.py",
            "line_num": 19
        }
    },
    "extra_menu_info": "statement:     self.x = 1",
    "insertion_text": "x"
}
```

C++:

```json
{
    "detailed_info": "Foo & operator=( const Foo & )\nFoo & operator=( Foo && )\n",
    "extra_menu_info": "Foo &",
    "insertion_text": "operator=",
    "kind": "FUNCTION",
    "menu_text": "operator=( const Foo & )"
}
```

Coalescing properties from the different responses together, the available
dictionary items become

```json
{
    "extra_data": {
        "location": {
            "column_num": 10,
            "filepath": "<path>",
            "line_num": 19
        },
        "required_namespace_import": null
    },
    "detailed_info": "",
    "extra_menu_info": "",
    "insertion_text": "",
    "kind": "",
    "menu_text": "",
}
```

where extra_data is presumably language specific.

### /load_extra_conf_file

This one seems safe to ignore.

```http
POST /load_extra_conf_file HTTP/1.1
```

The response object has a single property `filepath` which is an absolute path
to a `.ycm_extra_conf.py`.


### /defined_subcommands

Not sure what to make of this one. It looks like we need to return the supported
operations for the language.

```http
POST /defined_subcommands HTTP/1.1
```

Request object has several properties, but the only one of importance may be the
`completer_target` property.

```json
{
    "column_num": null,
    "completer_target": "python",
    "file_data": {
        "": {
            "contents": "",
            "filetypes": [
                null
            ]
        }
    },
    "filepath": "",
    "line_num": null
}
```

The response is a list of YCM subcommands as strings.

```json
[
    "GoToDefinition",
    "GoToDeclaration",
    "GoTo",
    "GetDoc"
]
```

### /run_completer_command

This seems to complement the `/defined_subcommands` endpoint. There is only one
request of this type in the example client output. **TODO:** Need to determine
if the request/response formats are shared by all subcommands.

```http
POST /run_completer_command HTTP/1.1
```

From the YCM README, there are numerous subcommands. The following commands are
relevant for a rust engine.

- **GoToInclude**: Maybe? `extern crate _` is sort of an "include". At best,
  this could go to the crate root. Maybe that's fine.
- **GoToDefinition**: Yes
- **GoTo**: Should be able to jump to definition
- **GoToImprecise**: Depends on what racer supports. May need to recompile every
  GoTo.
- **GetType**: echo type of variable under the cursor. Racer hopefully supports
  telling the type of type-inferred bindings.
- **GetParent**: echo semantic parent of point under cursor.
- **FixIt**: when returning `fixit_available: true` from a parse request, the
  FixIt subcommand applies the fix.
- **GetDoc**: Return the rustdoc string for identifier under cursor. If not
  available, return type or declaration of identifier.

These subcommands may be relevant - TBD. **TODO:** sort these into yes or no
before commencing work.

- **ClearCompilationFlagCache** - YCM caches FlagsForFile normally. This causes
  that list to recompute. This seems like a language independent thing, but the
  supported file types don't include everything YCM does. Maybe the other
  languages don't support compilation flags?
- **GotoImplementation**: Used for C# interfaces, but maybe useful for rust
  traits.
- **GoToImplementationElseDeclaration**: Ditto

The following subcommands are **not** relevant for a rust engine.

- **ReloadSolution**: Omnisharp specific
- **GoToDeclaration**: Rust definitions are DRY and do not have separate
  declarations.
- **StartServer**
- **StopServer**
- **RestartServer**


In any case, the request for `GoTo` follows.

```json
{
    "column_num": 4,
    "command_arguments": [
        "GoTo"
    ],
    "file_data": {
        "/Users/jwilm/code/ycmd/examples/samples/some_cpp.cpp": {
            "contents": "<contents>",
            "filetypes": [
                "cpp"
            ]
        }
    },
    "filepath": "/Users/jwilm/code/ycmd/examples/samples/some_cpp.cpp",
    "line_num": 23
}
```

And response in this case.

```json
{
    "column_num": 8,
    "filepath": "/Users/jwilm/code/ycmd/examples/samples/some_cpp.cpp",
    "line_num": 15
}
```

The `command_arguments` list suggests the request has a standard form. Response
is likely to be variable.
